{
  "ver": "1.0.27",
  "uuid": "7a7423db-ce68-4156-988a-bdab14cd3ec4",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform vec4 lights[30];\nuniform vec4 lightShadow[30];\nuniform vec4 lightSectors[60];\nuniform vec4 occluders[200];\nuniform float whRatio;\nbool lineSegmentIntersectOptimized(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n  if (max(p1.x, p2.x) < min(p3.x, p4.x) ||\n      max(p3.x, p4.x) < min(p1.x, p2.x) ||\n      max(p1.y, p2.y) < min(p3.y, p4.y) ||\n      max(p3.y, p4.y) < min(p1.y, p2.y)) {\n      return false;\n  }\n  vec2 a = p2 - p1;\n  vec2 b = p4 - p3;\n  vec2 c = p3 - p1;\n  float denom = a.x * b.y - a.y * b.x;\n  if (abs(denom) < 1e-6) {\n      return false;\n  }\n  float t = (c.x * b.y - c.y * b.x) / denom;\n  float u = (c.x * a.y - c.y * a.x) / denom;\n  return (t >= 0.0 && t <= 1.0 && u >= 0.0 && u <= 1.0);\n}\nbool isLightOccluder(vec2 lightPos) {\n  bool isCross = false;\n  vec2 bPos = vec2(0.0);\n  int nextNum = 0;\n  bool isLast = false;\n  for (int o_i = 0; o_i < 200; o_i++) {\n    if (o_i == nextNum) {\n      if (occluders[o_i].x <= 0.0) {\n        break;\n      }\n      isLast = occluders[o_i].y <= 0.0;\n      bPos = occluders[o_i].zw;\n      nextNum = o_i + int(occluders[o_i].x) + 1;\n    } else {\n      isCross = lineSegmentIntersectOptimized(v_uv0, lightPos, occluders[o_i-1].zw, occluders[o_i].xy);\n      if (isCross) {break;}\n      if (o_i+1 != nextNum || isLast) {\n        isCross = lineSegmentIntersectOptimized(v_uv0, lightPos, occluders[o_i].xy, occluders[o_i].zw);\n        if (isCross) {break;}\n      }\n      if (o_i+1 == nextNum) {\n        isCross = lineSegmentIntersectOptimized(v_uv0, lightPos, isLast ? occluders[o_i].zw : occluders[o_i].xy, bPos);\n        if (isCross) {break;}\n      }\n    }\n  }\n  return isCross;\n}\nfloat sectorRadDis(vec2 d, float direction, float angle) {\n  float r_angle = radians(angle);\n  float r_direction = radians(direction);\n  float theta = atan(d.y, d.x) - 0.5*3.14159265359 + r_direction;\n  float angleToAxis = abs(mod(theta , 2.0*3.14159265359) - 3.14159265359);\n  float angularDistance = angleToAxis - r_angle/2.0;\n  return angularDistance;\n}\nvoid main () {\n  vec4 col = vec4(1, 1, 1, 1);\n  col *= v_color;\n  for (int c_i = 0; c_i < 30; c_i++) {\n    if (lights[c_i].x <= -1.0 && lights[c_i].z <= -1.0) {\n      break;\n    }\n    vec2 v2 = v_uv0 - lights[c_i].xy;\n    v2.x *= whRatio;\n    float dis = length(v2);\n    if (dis <= (lights[c_i].z + lights[c_i].w)) {\n      bool isCross = false;\n      #if CALC_OCCLUDER\n        if (lightShadow[c_i].x > 0.5) {\n          isCross = isLightOccluder(lights[c_i].xy);\n        }\n      #endif\n      if (!isCross) {\n        if (dis <= lights[c_i].z) {\n          col.a = 0.0;\n          break;\n        } else if (lights[c_i].w > 0.0 && dis <= (lights[c_i].z + lights[c_i].w)) {\n          float t = smoothstep(0.0, 1.0, (dis - lights[c_i].z) / lights[c_i].w);\n          col.a -= (1.0-t);\n        }\n        if (col.a <= 0.0) {\n          col.a = 0.0;\n          break;\n        }\n      }\n    }\n  }\n  if (col.a > 0.0) {\n    vec4 vS1;\n    vec4 vS2;\n    for (int c_i = 0; c_i < 30; c_i+=2) {\n      if (lightSectors[c_i].x <= -1.0) {\n        break;\n      }\n      vS1 = lightSectors[c_i];\n      vS2 = lightSectors[c_i+1];\n      vec2 v2 = v_uv0 - vS1.xy;\n      v2.x *= whRatio;\n      float dis = length(v2);\n      float radDis2 = sectorRadDis(v2, vS1.z, vS2.z + vS2.w);\n      if (dis <= (vS2.x + vS2.y) && radDis2 <= 0.0) {\n        bool isCross = false;\n        #if CALC_OCCLUDER\n          if (vS1.w > 0.5) {\n            isCross = isLightOccluder(vS1.xy);\n          }\n        #endif\n        if (!isCross) {\n          float radDis = sectorRadDis(v2, vS1.z, vS2.z);\n          if (radDis <= 0.0) {\n            if (dis <= vS2.x) {\n              col.a = 0.0;\n            } else if (dis <= (vS2.x + vS2.y)) {\n              col.a -= smoothstep(1.0, 0.0, (dis - vS2.x) / vS2.y);\n            }\n          } else {\n            if (radDis2 <= 0.0) {\n              float a1 = smoothstep(0.0, 1.0, -radDis2 / (radDis -radDis2));\n              if (dis <= vS2.x) {\n                col.a -= a1;\n              } else if (dis <= (vS2.x + vS2.y)) {\n                float a2 = smoothstep(1.0, 0.0, (dis - vS2.x) / vS2.y);\n                col.a -= min(a1, a2);\n              }\n            }\n          }\n          if (col.a <= 0.0) {\n            col.a = 0.0;\n            break;\n          }\n        }\n      }\n    }\n  }\n  #if USE_BGRA\n    gl_FragColor = col.bgra;\n  #else\n    gl_FragColor = col.rgba;\n  #endif\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform Constant {\n  vec4 lights[30];\n  vec4 lightShadow[30];\n  vec4 lightSectors[30*2];\n  vec4 occluders[200];\n  float whRatio;\n};\nbool lineSegmentIntersectOptimized(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n  if (max(p1.x, p2.x) < min(p3.x, p4.x) ||\n      max(p3.x, p4.x) < min(p1.x, p2.x) ||\n      max(p1.y, p2.y) < min(p3.y, p4.y) ||\n      max(p3.y, p4.y) < min(p1.y, p2.y)) {\n      return false;\n  }\n  vec2 a = p2 - p1;\n  vec2 b = p4 - p3;\n  vec2 c = p3 - p1;\n  float denom = a.x * b.y - a.y * b.x;\n  if (abs(denom) < 1e-6) {\n      return false;\n  }\n  float t = (c.x * b.y - c.y * b.x) / denom;\n  float u = (c.x * a.y - c.y * a.x) / denom;\n  return (t >= 0.0 && t <= 1.0 && u >= 0.0 && u <= 1.0);\n}\nbool isLightOccluder(vec2 lightPos) {\n  bool isCross = false;\n  vec2 bPos = vec2(0.0);\n  int nextNum = 0;\n  bool isLast = false;\n  for (int o_i = 0; o_i < 200; o_i++) {\n    if (o_i == nextNum) {\n      if (occluders[o_i].x <= 0.0) {\n        break;\n      }\n      isLast = occluders[o_i].y <= 0.0;\n      bPos = occluders[o_i].zw;\n      nextNum = o_i + int(occluders[o_i].x) + 1;\n    } else {\n      isCross = lineSegmentIntersectOptimized(v_uv0, lightPos, occluders[o_i-1].zw, occluders[o_i].xy);\n      if (isCross) {break;}\n      if (o_i+1 != nextNum || isLast) {\n        isCross = lineSegmentIntersectOptimized(v_uv0, lightPos, occluders[o_i].xy, occluders[o_i].zw);\n        if (isCross) {break;}\n      }\n      if (o_i+1 == nextNum) {\n        isCross = lineSegmentIntersectOptimized(v_uv0, lightPos, isLast ? occluders[o_i].zw : occluders[o_i].xy, bPos);\n        if (isCross) {break;}\n      }\n    }\n  }\n  return isCross;\n}\nfloat sectorRadDis(vec2 d, float direction, float angle) {\n  float r_angle = radians(angle);\n  float r_direction = radians(direction);\n  float theta = atan(d.y, d.x) - 0.5*3.14159265359 + r_direction;\n  float angleToAxis = abs(mod(theta , 2.0*3.14159265359) - 3.14159265359);\n  float angularDistance = angleToAxis - r_angle/2.0;\n  return angularDistance;\n}\nvoid main () {\n  vec4 col = vec4(1, 1, 1, 1);\n  col *= v_color;\n  for (int c_i = 0; c_i < 30; c_i++) {\n    if (lights[c_i].x <= -1.0 && lights[c_i].z <= -1.0) {\n      break;\n    }\n    vec2 v2 = v_uv0 - lights[c_i].xy;\n    v2.x *= whRatio;\n    float dis = length(v2);\n    if (dis <= (lights[c_i].z + lights[c_i].w)) {\n      bool isCross = false;\n      #if CALC_OCCLUDER\n        if (lightShadow[c_i].x > 0.5) {\n          isCross = isLightOccluder(lights[c_i].xy);\n        }\n      #endif\n      if (!isCross) {\n        if (dis <= lights[c_i].z) {\n          col.a = 0.0;\n          break;\n        } else if (lights[c_i].w > 0.0 && dis <= (lights[c_i].z + lights[c_i].w)) {\n          float t = smoothstep(0.0, 1.0, (dis - lights[c_i].z) / lights[c_i].w);\n          col.a -= (1.0-t);\n        }\n        if (col.a <= 0.0) {\n          col.a = 0.0;\n          break;\n        }\n      }\n    }\n  }\n  if (col.a > 0.0) {\n    vec4 vS1;\n    vec4 vS2;\n    for (int c_i = 0; c_i < 30; c_i+=2) {\n      if (lightSectors[c_i].x <= -1.0) {\n        break;\n      }\n      vS1 = lightSectors[c_i];\n      vS2 = lightSectors[c_i+1];\n      vec2 v2 = v_uv0 - vS1.xy;\n      v2.x *= whRatio;\n      float dis = length(v2);\n      float radDis2 = sectorRadDis(v2, vS1.z, vS2.z + vS2.w);\n      if (dis <= (vS2.x + vS2.y) && radDis2 <= 0.0) {\n        bool isCross = false;\n        #if CALC_OCCLUDER\n          if (vS1.w > 0.5) {\n            isCross = isLightOccluder(vS1.xy);\n          }\n        #endif\n        if (!isCross) {\n          float radDis = sectorRadDis(v2, vS1.z, vS2.z);\n          if (radDis <= 0.0) {\n            if (dis <= vS2.x) {\n              col.a = 0.0;\n            } else if (dis <= (vS2.x + vS2.y)) {\n              col.a -= smoothstep(1.0, 0.0, (dis - vS2.x) / vS2.y);\n            }\n          } else {\n            if (radDis2 <= 0.0) {\n              float a1 = smoothstep(0.0, 1.0, -radDis2 / (radDis -radDis2));\n              if (dis <= vS2.x) {\n                col.a -= a1;\n              } else if (dis <= (vS2.x + vS2.y)) {\n                float a2 = smoothstep(1.0, 0.0, (dis - vS2.x) / vS2.y);\n                col.a -= min(a1, a2);\n              }\n            }\n          }\n          if (col.a <= 0.0) {\n            col.a = 0.0;\n            break;\n          }\n        }\n      }\n    }\n  }\n  #if USE_BGRA\n    gl_FragColor = col.bgra;\n  #else\n    gl_FragColor = col.rgba;\n  #endif\n}"
      }
    }
  ],
  "subMetas": {}
}